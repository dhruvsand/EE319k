


ARM Macro Assembler    Page 1 


    1 00000000         ;*****Your name goes here*******
    2 00000000         ; -5 points if you do not add your name
    3 00000000         ; DHRUV SANDESARA;
    4 00000000         ; 60 MINS
    5 00000000         ;This is Exam2_Calculus 
    6 00000000         ;EE319K Spring 2013
    7 00000000         ;March 28, 2013
    8 00000000         ;You edit this file only
    9 00000000         
   10 00000000         
   11 00000000 80000000 
                       DATAERR EQU              0X80000000
   12 00000000                 AREA             Data, ALIGN=4
   13 00000000         
   14 00000000         
   15 00000000                 AREA             |.text|, CODE, READONLY, ALIGN=
2
   16 00000000                 THUMB
   17 00000000         
   18 00000000         ;***** Size subroutine*********************
   19 00000000         ;Determines the number of elements in a variable-length 
                       array
   20 00000000         ;Each element of the array is a 16-bit signed number
   21 00000000         ;The array has a termination code of -32768
   22 00000000         ;The -32768 is not a data point in the array
   23 00000000         ;Input:   R0 has a pointer to the array of 16-bit number
                       s
   24 00000000         ;Output:  R0 is returned as the number of data elements 
                       in the array 
   25 00000000         ;Invariables: You must not permanently modify registers 
                       R4 to R11, and LR
   26 00000000         ;Error conditions: none
   27 00000000         ;Test cases
   28 00000000         ;Array0 DCW 35,144,25,36,-32768              ;size = 4
   29 00000000         ;Array1 DCW 9,13,-4,-5,100,-2000,7000,-32768 ;size = 7
   30 00000000         ;Array2 DCW 0,128,0,128,128,-32768           ;size = 5
   31 00000000         ;Array3 DCW -32768                           ;size = 0
   32 00000000                 EXPORT           Size
   33 00000000         DATA
   34 00000000 00 80           DCW              -32768
   35 00000002         
   36 00000002         Size
   37 00000002         ; put your code here
   38 00000002 E92D 01FE       PUSH             {R1-R8}     ;
   39 00000006 4A3A            LDR              R2,=DATA
   40 00000008 F9B2 2000       LDRSH            R2,[R2]     ;
   41 0000000C F04F 0300       MOV              R3,#0       ;
   42 00000010         
   43 00000010         SIZELOOP
   44 00000010 F9B0 1000       LDRSH            R1,[R0]     ;
   45 00000014 4291            CMP              R1,R2       ;
   46 00000016 D004            BEQ              SIZEDONE    ;
   47 00000018 F103 0301       ADD              R3,#1       ;
   48 0000001C F100 0002       ADD              R0,#2       ;
   49 00000020 E7F6            B                SIZELOOP    ;
   50 00000022         
   51 00000022         
   52 00000022         
   53 00000022         SIZEDONE



ARM Macro Assembler    Page 2 


   54 00000022 4618            MOV              R0,R3       ;
   55 00000024         
   56 00000024 E8BD 01FE       POP              {R1-R8}
   57 00000028         
   58 00000028         
   59 00000028 4770            BX               LR
   60 0000002A         
   61 0000002A         ;***** Derivative subroutine*********************
   62 0000002A         ;Calculates the derivative between two points
   63 0000002A         ;Assumes the two points were measured 0.1 sec apart
   64 0000002A         ;Inputs:  R0 is the first data value
   65 0000002A         ;         R1 is the second data value
   66 0000002A         ;R0 and R1 can vary from -32767 to +32767
   67 0000002A         ;Output:  return R0 = (second-first)*10
   68 0000002A         ;the output value can vary from -655340 to +655340
   69 0000002A         ;overflow can not happen in this function
   70 0000002A         ;Invariables: You must not permanently modify registers 
                       R4 to R11, and LR
   71 0000002A         ;Error conditions: none
   72 0000002A         ;Test cases
   73 0000002A         ;R0=10,     R1=-10    yields R0 = -200
   74 0000002A         ;R0=-10,    R1=10     yields R0 = 200
   75 0000002A         ;R0=32767,  R1=-32767 yields R0 = -655340
   76 0000002A         ;R0=-20000, R1=-10000 yields R0 = 100000
   77 0000002A                 EXPORT           Derivative
   78 0000002A         Derivative
   79 0000002A         
   80 0000002A         ; put your code here
   81 0000002A EBA1 0000       SUB              R0,R1,R0
   82 0000002E F04F 010A       MOV              R1,#10      ;
   83 00000032 FB00 F001       MUL              R0,R0,R1    ;
   84 00000036         
   85 00000036         
   86 00000036         
   87 00000036 4770            BX               LR
   88 00000038         
   89 00000038         ;***** Integration subroutine *********************
   90 00000038         ;Determines the integral of elements in a variable-lengt
                       h array
   91 00000038         ;Assumes the points in the array were measured 0.1 sec a
                       part
   92 00000038         ;Each element of the array is a 16-bit signed number
   93 00000038         ;The array has a termination code of -32768
   94 00000038         ;The -32768 is not a data point in the array
   95 00000038         ;Input:   R0 has a pointer to the array of 16-bit number
                       s
   96 00000038         ;Output:  return R0 is returned as the integral of data 
                       elements in the array 
   97 00000038         ;The integral is the sum of all data points divided by 1
                       0
   98 00000038         ;First calculate the sum, and then divide the sum by 10
   99 00000038         ;Do not worry about overflow during the additions
  100 00000038         ;Invariables: You must not permanently modify registers 
                       R4 to R11, and LR
  101 00000038         ;Error conditions: none
  102 00000038         ;Test cases
  103 00000038         ;Array4 DCW 35,144,25,36,-32768              ;I = (35+14
                       4+25+36)/10 = 24
  104 00000038         ;Array5 DCW 9,13,-4,-5,100,-2000,7000,-32768 ;I = (9+13-



ARM Macro Assembler    Page 3 


                       4-5+100-2000+7000)/10 = 511
  105 00000038         ;Array6 DCW 20000,25000,25000,30000,20000,25000,25000,30
                       000,20000,25000,25000,30000,20000,25000,25000,30000,-327
                       68                  ;I = 40000
  106 00000038         ;Array7 DCW -20000,-25000,-25000,-30000,-20000,-25000,-2
                       5000,-30000,-20000,-25000,-25000,-30000,-20000,-25000,-2
                       5000,-30000,-32768  ;I = -40000
  107 00000038         ;Array8 DCW -32768                           ;I = 0
  108 00000038         DATA2
  109 00000038 00 80           DCW              -32768
  110 0000003A                 EXPORT           Integration
  111 0000003A         Integration
  112 0000003A         ; put your code here
  113 0000003A E92D 01FE       PUSH             {R1-R8}     ;
  114 0000003E 4A2D            LDR              R2,=DATA2   ;
  115 00000040 F9B2 2000       LDRSH            R2,[R2]     ;
  116 00000044 F04F 0300       MOV              R3,#0       ;
  117 00000048 F04F 040A       MOV              R4,#10      ;
  118 0000004C         
  119 0000004C         INTLOOP
  120 0000004C F9B0 1000       LDRSH            R1,[R0]     ;
  121 00000050 4291            CMP              R1,R2       ;
  122 00000052 D003            BEQ              INTDONE     ;
  123 00000054 440B            ADD              R3,R1       ;
  124 00000056 F100 0002       ADD              R0,#2       ;
  125 0000005A E7F7            B                INTLOOP     ;
  126 0000005C         
  127 0000005C         
  128 0000005C         
  129 0000005C         INTDONE
  130 0000005C FB93 F3F4       SDIV             R3,R3,R4    ;
  131 00000060 4618            MOV              R0,R3       ;
  132 00000062         
  133 00000062 E8BD 01FE       POP              {R1-R8}
  134 00000066         
  135 00000066         
  136 00000066         
  137 00000066 4770            BX               LR
  138 00000068         DATA3
  139 00000068 00 80           DCW              -32768
  140 0000006A         ;DATAERR
  141 0000006A         ; DCD 0X80000000;
  142 0000006A         
  143 0000006A         ;***** MaxDerivative subroutine *********************
  144 0000006A         ;Determines the maximum derivative of elements in a vari
                       able-length array
  145 0000006A         ;Assumes the points in the array were measured 0.1 sec a
                       part
  146 0000006A         ;Each element of the array is a 16-bit signed number
  147 0000006A         ;The array has a termination code of -32768
  148 0000006A         ;The -32768 is not a data point in the array
  149 0000006A         ;An array of n elements has n-1 derivatives.
  150 0000006A         ;Each derivative is calculated using adjacent elements: 
                       (second-first)*10
  151 0000006A         ;Input:   R0 has a pointer to the array of 16-bit number
                       s
  152 0000006A         ;Output:  R0 is returned as the maximum derivative of da
                       ta elements in the array 
  153 0000006A         ;The integral is the sum of all data points divided by 1



ARM Macro Assembler    Page 4 


                       0
  154 0000006A         ;Invariables: You must not permanently modify registers 
                       R4 to R11, and LR
  155 0000006A         ;Error conditions: return 0x80000000 if the array has ze
                       ro or one element
  156 0000006A         ;Test cases
  157 0000006A         ;Array9  DCW 35,144,25,36,-32768              ;derivativ
                       es are 1090,-1190,110; max is 1090
  158 0000006A         ;Array10 DCW 9,13,-4,-5,100,-2000,7000,-32768 ;derivativ
                       es are 40,-170,-10,1050,-21000,90000; max is 90000
  159 0000006A         ;Array11 DCW 4,2,0,-4,-5,-9,-12,-32768        ;derivativ
                       es are -20,-20,-40,-10,-40,-30; max is -10
  160 0000006A         ;Array12 DCW 10,0,-32768                      ;derivativ
                       e is -100; max is -100
  161 0000006A         ;Array13 DCW 10,-32768                        ;error cas
                       e, return 0x80000000
  162 0000006A         ;Array14 DCW -32768                           ;error cas
                       e, return 0x80000000
  163 0000006A                 EXPORT           MaxDerivative
  164 0000006A         
  165 0000006A         
  166 0000006A         MaxDerivative
  167 0000006A B5FE            PUSH             {R1-R7,LR}  ;
  168 0000006C 4A22            LDR              R2,=DATA3   ;
  169 0000006E F9B2 2000       LDRSH            R2,[R2]     ;
  170 00000072 4603            MOV              R3,R0       ;
  171 00000074 F04F 0400       MOV              R4,#0       ;
  172 00000078 F04F 050A       MOV              R5,#10      ;
  173 0000007C         
  174 0000007C         
  175 0000007C F9B3 0000       LDRSH            R0,[R3]     ;
  176 00000080 F9B3 1002       LDRSH            R1,[R3,#2]  ;
  177 00000084 4290            CMP              R0,R2       ;
  178 00000086 D018            BEQ              ERROR
  179 00000088 4291            CMP              R1,R2       ;
  180 0000008A D016            BEQ              ERROR       ;
  181 0000008C EBA1 0400       SUB              R4,R1,R0    ;
  182 00000090 FB04 F405       MUL              R4,R4,R5    ;
  183 00000094 4626            MOV              R6,R4       ;
  184 00000096         
  185 00000096         MAXLOOP
  186 00000096 F9B3 0000       LDRSH            R0,[R3]     ;
  187 0000009A F9B3 1002       LDRSH            R1,[R3,#2]  ;
  188 0000009E 4291            CMP              R1,R2       ;
  189 000000A0 D009            BEQ              MAXNORMALDONE ;
  190 000000A2 EBA1 0400       SUB              R4,R1,R0    ;
  191 000000A6 FB04 F405       MUL              R4,R4,R5    ;
  192 000000AA 42B4            CMP              R4,R6       ;
  193 000000AC DB00            BLT              MAXSKIP
  194 000000AE 4626            MOV              R6,R4       ;
  195 000000B0         MAXSKIP
  196 000000B0 F103 0302       ADD              R3,#2       ;
  197 000000B4 E7EF            B                MAXLOOP     ;
  198 000000B6         
  199 000000B6         
  200 000000B6         
  201 000000B6         MAXNORMALDONE
  202 000000B6 4630            MOV              R0,R6       ;
  203 000000B8 E001            B                MAXDONE



ARM Macro Assembler    Page 5 


  204 000000BA         
  205 000000BA         ERROR
  206 000000BA F04F 4000       LDR              R0,=DATAERR ;
  207 000000BE         ;LDR R0,[R0]
  208 000000BE         MAXDONE
  209 000000BE E8BD 40FE       POP              {R1-R7,LR}  ;
  210 000000C2         
  211 000000C2 4770            BX               LR
  212 000000C4         
  213 000000C4         ;***** Ave6 subroutine *********************
  214 000000C4         ;Determines the average of six 32-bit unsigned numbers
  215 000000C4         ;Average is (n1+n2+n3+n4+n5+n6)/6
  216 000000C4         ;Do not worry about rounding (perform simple integer div
                       ision)
  217 000000C4         ;Do worry about overflow during the addition steps
  218 000000C4         ;Input:   R0 is n1
  219 000000C4         ;         R1 is n2
  220 000000C4         ;         R2 is n3
  221 000000C4         ;         R3 is n4
  222 000000C4         ;         top of stack is n5
  223 000000C4         ;         next to top of stack is n6
  224 000000C4         ;Output:  R0 is returned as the average of the six numbe
                       rs 
  225 000000C4         ;Invariables: You must not permanently modify registers 
                       R4 to R11, and LR
  226 000000C4         ;You will need to access the stack, but do not permanent
                       ly add or remove items from stack         
  227 000000C4         ;Error conditions: return 0xFFFFFFFF on overflow
  228 000000C4         ;Test cases
  229 000000C4         ; 1,2,3,5,6,7                       has an average of 4
  230 000000C4         ; 0x80000000,0x80000000,0,0,0,0     overflow output = 0x
                       FFFFFFFF
  231 000000C4         ; 0x90000000,0,0xE0000000,0,0,0     overflow output = 0x
                       FFFFFFFF
  232 000000C4         ; 0xC0000000,0,0,0,0,0xF0000000,0   overflow output = 0x
                       FFFFFFFF
  233 000000C4         ; 0xA0000000,1,0xB0000000,0,0,0     overflow output = 0x
                       FFFFFFFF
  234 000000C4                 EXPORT           Ave6
  235 000000C4         Ave6
  236 000000C4         ; put your code here
  237 000000C4 1840            ADDS             R0,R0,R1    ;
  238 000000C6 D20F            BCS              OVERFLOWERROR
  239 000000C8 F04F 0106       MOV              R1,#6       ;
  240 000000CC 1880            ADDS             R0,R0,R2    ;
  241 000000CE D20B            BCS              OVERFLOWERROR
  242 000000D0 18C0            ADDS             R0,R0,R3    ;
  243 000000D2 D209            BCS              OVERFLOWERROR
  244 000000D4         
  245 000000D4 466A            MOV              R2,SP       ;
  246 000000D6 6813            LDR              R3,[R2]     ;
  247 000000D8         
  248 000000D8         
  249 000000D8 18C0            ADDS             R0,R0,R3    ;
  250 000000DA D205            BCS              OVERFLOWERROR
  251 000000DC         
  252 000000DC 6853            LDR              R3,[R2,#4]  ;
  253 000000DE 18C0            ADDS             R0,R0,R3    ;
  254 000000E0 FBB0 F0F1       UDIV             R0,R0,R1    ;



ARM Macro Assembler    Page 6 


  255 000000E4 D200            BCS              OVERFLOWERROR
  256 000000E6         
  257 000000E6         
  258 000000E6 E001            B                AVE6DONE
  259 000000E8         
  260 000000E8         OVERFLOWERROR
  261 000000E8 F04F 30FF       MOV              R0,#-1
  262 000000EC         
  263 000000EC         AVE6DONE
  264 000000EC         
  265 000000EC 4770            BX               LR
  266 000000EE 00 00           ALIGN
  267 000000F0                 END
              00000000 
              00000000 
              00000000 
Command Line: --debug --xref --cpu=Cortex-M3 --apcs=interwork --depend=.\exam2.
d -o.\exam2.o -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\
Inc\Luminary --predefine="__EVAL SETA 1" --list=.\exam2.lst Exam2.s



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Relocatable symbols

Data 00000000

Symbol: Data
   Definitions
      At line 12 in file Exam2.s
   Uses
      None
Comment: Data unused
1 symbol



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Relocatable symbols

.text 00000000

Symbol: .text
   Definitions
      At line 15 in file Exam2.s
   Uses
      None
Comment: .text unused
AVE6DONE 000000EC

Symbol: AVE6DONE
   Definitions
      At line 263 in file Exam2.s
   Uses
      At line 258 in file Exam2.s
Comment: AVE6DONE used once
Ave6 000000C4

Symbol: Ave6
   Definitions
      At line 235 in file Exam2.s
   Uses
      At line 234 in file Exam2.s
Comment: Ave6 used once
DATA 00000000

Symbol: DATA
   Definitions
      At line 33 in file Exam2.s
   Uses
      At line 39 in file Exam2.s
Comment: DATA used once
DATA2 00000038

Symbol: DATA2
   Definitions
      At line 108 in file Exam2.s
   Uses
      At line 114 in file Exam2.s
Comment: DATA2 used once
DATA3 00000068

Symbol: DATA3
   Definitions
      At line 138 in file Exam2.s
   Uses
      At line 168 in file Exam2.s
Comment: DATA3 used once
Derivative 0000002A

Symbol: Derivative
   Definitions
      At line 78 in file Exam2.s
   Uses
      At line 77 in file Exam2.s
Comment: Derivative used once
ERROR 000000BA

Symbol: ERROR



ARM Macro Assembler    Page 2 Alphabetic symbol ordering
Relocatable symbols

   Definitions
      At line 205 in file Exam2.s
   Uses
      At line 178 in file Exam2.s
      At line 180 in file Exam2.s

INTDONE 0000005C

Symbol: INTDONE
   Definitions
      At line 129 in file Exam2.s
   Uses
      At line 122 in file Exam2.s
Comment: INTDONE used once
INTLOOP 0000004C

Symbol: INTLOOP
   Definitions
      At line 119 in file Exam2.s
   Uses
      At line 125 in file Exam2.s
Comment: INTLOOP used once
Integration 0000003A

Symbol: Integration
   Definitions
      At line 111 in file Exam2.s
   Uses
      At line 110 in file Exam2.s
Comment: Integration used once
MAXDONE 000000BE

Symbol: MAXDONE
   Definitions
      At line 208 in file Exam2.s
   Uses
      At line 203 in file Exam2.s
Comment: MAXDONE used once
MAXLOOP 00000096

Symbol: MAXLOOP
   Definitions
      At line 185 in file Exam2.s
   Uses
      At line 197 in file Exam2.s
Comment: MAXLOOP used once
MAXNORMALDONE 000000B6

Symbol: MAXNORMALDONE
   Definitions
      At line 201 in file Exam2.s
   Uses
      At line 189 in file Exam2.s
Comment: MAXNORMALDONE used once
MAXSKIP 000000B0

Symbol: MAXSKIP
   Definitions
      At line 195 in file Exam2.s



ARM Macro Assembler    Page 3 Alphabetic symbol ordering
Relocatable symbols

   Uses
      At line 193 in file Exam2.s
Comment: MAXSKIP used once
MaxDerivative 0000006A

Symbol: MaxDerivative
   Definitions
      At line 166 in file Exam2.s
   Uses
      At line 163 in file Exam2.s
Comment: MaxDerivative used once
OVERFLOWERROR 000000E8

Symbol: OVERFLOWERROR
   Definitions
      At line 260 in file Exam2.s
   Uses
      At line 238 in file Exam2.s
      At line 241 in file Exam2.s
      At line 243 in file Exam2.s
      At line 250 in file Exam2.s
      At line 255 in file Exam2.s

SIZEDONE 00000022

Symbol: SIZEDONE
   Definitions
      At line 53 in file Exam2.s
   Uses
      At line 46 in file Exam2.s
Comment: SIZEDONE used once
SIZELOOP 00000010

Symbol: SIZELOOP
   Definitions
      At line 43 in file Exam2.s
   Uses
      At line 49 in file Exam2.s
Comment: SIZELOOP used once
Size 00000002

Symbol: Size
   Definitions
      At line 36 in file Exam2.s
   Uses
      At line 32 in file Exam2.s
Comment: Size used once
20 symbols



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Absolute symbols

DATAERR 80000000

Symbol: DATAERR
   Definitions
      At line 11 in file Exam2.s
   Uses
      At line 206 in file Exam2.s
Comment: DATAERR used once
1 symbol
355 symbols in table

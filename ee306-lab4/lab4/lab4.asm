.ORIG x3000
; Start your program here

AND R6,R6,#0		; R6 WILL STORE THE PLAYERS TURN
START
LD R0, NEWLINE
OUT
LD R0, NEWLINE		; 2 NEW LINES JUST FOR CLEANLINESS
OUT
LEA R0,ROWA		; THE ROW 1 OUTPUT STARTER
PUTS


LD R1,VALUEA

LOOP1 
ADD R1,R1,#0
BRZ SKIPROCKA
LD R0,ROCK		; OUTPUTING ROCKS BASED ON THE VALUES STORED IN THE MEMORY LOCATION
OUT
ADD R1,R1,#-1
BRP LOOP1


SKIPROCKA
LD R0, NEWLINE
OUT
LEA R0,ROWB		; DOING THE SAME FOR ROW B
PUTS

LD R1,VALUEB

LOOP2 
ADD R1,R1,#0
BRZ SKIPROCKB
LD R0,ROCK		; DOING SAME FOR OUTPUTING ROCKS IN ROW B
OUT
ADD R1,R1,#-1
BRP LOOP2

SKIPROCKB
LD R0, NEWLINE
OUT
LEA R0,ROWC		;SAME FOR ROW C
PUTS

LD R1,VALUEC

LOOP3 
ADD R1,R1,#0
BRZ PLAYERCHOOSE	; SAME FOR ROW C
LD R0,ROCK
OUT
ADD R1,R1,#-1
BRP LOOP3





PLAYERCHOOSE
ADD R6,R6,#0
BRN TURN2		; DECIDES WHICH PLAYERS TURN IT IS BASED ON VALUE IN R6
LD R0, NEWLINE
OUT
LEA R0,PLAYER1PROMPT	; OUTPUT FOR PLAYER 1
PUTS
BR INPUT

TURN2
LD R0, NEWLINE
OUT
LEA R0,PLAYER2PROMPT	; FOR PLAYER 2
PUTS

INPUT
GETC
OUT
AND R2,R2,#0
ADD R2,R2,R0		;TAKING FIRST CHARACTER INPUT INTO R2
GETC
OUT
AND R3,R3,#0
ADD R3,R3,R0		;TAKING SECOND CHARACTER INPUT INTO R3





LD R1,ASCIIC
NOT R1,R1
ADD R1,R1,#1		;TAKING INVERSE OF THE ASCII VALUE OF CHARACTER CAPITAL C

LEA R5,VALUEC		;LOADING THE ROW VALUE DENOTING ROCKS IN ROW C INTO R4 AND STORING THE ADRESS OF WHERE THIS DATA IS STORED IN R5 SO WE CAN WRITE TO IT AFTER CALCULATION
LD R4,VALUEC
ADD R2,R2,R1;		;CHECKING IF INPUT CHARACTER WAS C
BRZ ROCKCALCULATE

LEA R5,VALUEB
LD R4,VALUEB		;DOING SAME FOR B
ADD R2,R2,#1		;CHECKING IF IT WAS ROW B AS IF IT WAS B AND WE HAD SUBTRACTED C THE VALUE WOULD BE NEGATIVE 1 
BRZ ROCKCALCULATE

LEA R5,VALUEA
LD R4,VALUEA
ADD R2,R2,#1		;DOING SAME FOR CHARACTER A
BRZ ROCKCALCULATE



INVALIDLOOP
LD R0, NEWLINE
OUT
LEA R0,INVALID		; INCASE THE INPUT WAS NOT A,B OR C OR IF THE VALUE EXCEEDED THE CURRENT ROCK COUNT
PUTS
BR PLAYERCHOOSE



ROCKCALCULATE

LD R0,ASCII0
NOT R0,R0
ADD R0,R0,#1		;INVERSE OF ASCII VALUE OF 0 SO WE CAN ADD IT TO THE VALUE CHARACTER AND DETERMINE THE VALUE

ADD R1,R0,R3      	;CHECKING IF VALUE IS SMALLER THAN 1. IF SO IT IS INVALID
BRNZ INVALIDLOOP 

ADD R1,R1,#-8		;CHECKING IF VALUE IS GREATER THAN 8. IF SO IT IS INVALID
BRP INVALIDLOOP

ADD R3,R3,R0		;CONVERTIG VALUE TO DECIMAL AS DIFFERENCE OF ASCII VALUE INPUTED AND ASCII VALUE OF 0 WILL GIVE US THE PROPER DIGIT
NOT R3,R3
ADD R3,R3,#1		;TAKING NEGATIVE OF VALUE

ADD R2,R3,R4            ; CHECKING IF THE VALUE THE USER INPUTED IS LARGER THAN THE ROCKS ACTUALLY HE/SHE IS ALLOWED TO REMOVE
BRN INVALIDLOOP

STR R2,R5,#0		; STORING THE NEW ROCK COUNT IN THE APPROPRIATE MEMORY LOCATION

NOT R6,R6		;SWITHING PLAYERS

LD R0,VALUEA		;IF THERE ARE ANY ROCKS REMAINING THE GAME MUST GO ON. IF NOT GO THE THE WINNER DECLERATION PLACE
BRP START
LD R0,VALUEB
BRP START
LD R0,VALUEC
BRP START


ADD R6,R6,#0		;CHEKING WHOSE TURN IT IS. AS WE HAVE ALREADY FLIPPED TURNS WHOEVERS TURN IT IS HAS WON
BRN WIN2		; NEGATIVE VALUE MEANS PLAYER 2 AND POSITIVE VALUE IS PLAYER 1
LD R0, NEWLINE
OUT
LD R0, NEWLINE
OUT
LEA R0,PLAYER1WINS	;OUTPUTING THE WINER DECLEARATIONS
PUTS
BR END

WIN2
LD R0, NEWLINE
OUT
LD R0, NEWLINE
OUT
LEA R0,PLAYER2WINS
PUTS







END
; End your program here
HALT

NEWLINE .FILL X000A
ROCK	.FILL X006F

ROWA .STRINGZ "ROW A:"
ROWB .STRINGZ "ROW B:"
ROWC .STRINGZ "ROW C:"

VALUEA 	.FILL X0003
VALUEB	.FILL X0005
VALUEC	.FILL X0008

PLAYER1PROMPT .STRINGZ "Player 1, choose a row and number of rocks: "
PLAYER2PROMPT .STRINGZ "Player 2, choose a row and number of rocks: "

INVALID .STRINGZ "Invalid move. Try again."

PLAYER1WINS .STRINGZ "Player 1 Wins."
PLAYER2WINS .STRINGZ "Player 2 Wins."

ASCIIA .FILL X0041
ASCIIB .FILL X0042
ASCIIC .FILL X0043
ASCII0 .FILL X0030


; Start your data here

; End your data here
.END
